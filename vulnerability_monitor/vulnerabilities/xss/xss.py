
import time , os , subprocess , colorama , requests 
from asset_monitor.models import *

OUTPUT_PATH = 'vulnerability_monitor/vulnerabilities/xss/outputs'

def sendmessage(message: str, telegram: bool = False, colour: str = "YELLOW", logger : str = "logger.txt" , silent : bool = False):
    color = getattr(colorama.Fore, colour, colorama.Fore.YELLOW)

    print(color + message + colorama.Style.RESET_ALL)

    time_string = time.strftime("%d/%m/%Y, %H:%M:%S", time.localtime())

    if logger:
        with open(logger, 'a') as file:
            file.write(message + ' -> ' + time_string + '\n')

    if telegram:
        bot_token = {BOT_TOKEN}
        chat_id = "5028701156"
        url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
        payload = {'chat_id': chat_id, 'text': message}

        try:
            response = requests.post(url, data=payload, timeout=10)
            response.raise_for_status()
        except requests.exceptions.RequestException as e:
            sendmessage(f"[ERROR] Telegram message failed: {e}", colour="RED")


def read_write_list(list_data: list, file: str, type: str):

    objects = []
    
    if type == "read" or type == 'r':
        with open(file, 'r') as f:
            objects = list(set(line.strip() for line in f.read().splitlines() if line.strip()))
        return objects

    
    elif type == "write" or type == 'w': 
        with open(file, 'w') as f:
            for item in set(list_data):
                f.write(item.strip() + '\n')


    elif type == "append" or type == 'a':
        try:
            with open(file, 'r') as f:
                existing_items = set(f.read().splitlines())
        except FileNotFoundError:
            existing_items = set()
        
        with open(file, 'a') as f:
            for item in set(list_data):
                if item.strip() and item not in existing_items:
                    f.write(item.strip() + '\n')


def run_fallparams(url_path, thread, delay, method , headers):
    sendmessage(f"  [INFO] Starting parameter discovery and check reflection (method: {method}) {url}", colour="YELLOW" , logger=logger , silent=silent)

    try:
        command = [
        "fallparams",
        "-u",url_path,
        "-X",method,
        '-silent',
        '-duc',
        ]
        for key, value in headers.items():
            command.extend(["-H", f"{key}: {value}"])
        result = subprocess.run(
            command,
            shell=False,
            check=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        parameters = result.stdout.splitlines()
        sendmessage(f"      [INFO] {len(parameters)} parameters found ", logger=logger , silent=silent)
        return parameters
    except Exception as e:
        sendmessage(f"  [ERROR] Error fallparams URL {url_path}: {str(e)}", colour="RED", logger=logger, silent=silent)
        return


def XSS(self):
    subdomains = DiscoverSubdomain.objects.all().order_by("-label")
    
    for subdomain in subdomains:    
        headers = subdomain.wildcard.requestheaders_set.all().values_list('header' , flat=True)
        urls = list(subdomain.url_set.filter(label='new').values_list('url', flat=True))
        read_write_list(urls , f'{OUTPUT_PATH}/urls.txt', 'w')
        #run_fallparams(f'{OUTPUT_PATH}/urls.txt', thread, delay, method , headers)