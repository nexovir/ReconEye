
import colorama, time, subprocess, requests , re
from asset_monitor.models import *
from urllib.parse import urlparse, parse_qsl, urlencode, urlunparse , parse_qs
from vulnerability_monitor.models import *
import concurrent.futures , requests , urllib.parse
from programs_monitor.tasks import sendmessage

PAYLOADS = ['%22zerodium' , '%27zerodium' , '%3Ezerodium']
OUTPUT_PATH = 'vulnerability_monitor/vulnerabilities/xss/outputs'

def clear_labels(self):
    XSSReport.objects.all().update(label="available")


def read_write_list(list_data: list, file: str, type: str):
    objects = []
    
    if type == "read" or type == 'r':
        with open(file, 'r') as f:
            objects = list(set(line.strip() for line in f.read().splitlines() if line.strip()))
        return objects

    
    elif type == "write" or type == 'w': 
        with open(file, 'w') as f:
            for item in set(list_data):
                f.write(item.strip() + '\n')


    elif type == "append" or type == 'a':
        try:
            with open(file, 'r') as f:
                existing_items = set(f.read().splitlines())
        except FileNotFoundError:
            existing_items = set()
        
        with open(file, 'a') as f:
            for item in set(list_data):
                if item.strip() and item not in existing_items:
                    f.write(item.strip() + '\n')


def try_to_xss(asset, method, url , protocol):
    def test_payload(payload):
        try:
            url_payload = url.replace("zerodium", payload)
            resp = requests.get(url_payload, timeout=5)
            text = resp.text

            decoded = urllib.parse.unquote(payload)

            if decoded in text:
                exists = XSSReport.objects.filter(asset=asset , method=method, level='medium',  url=url_payload).exists()
                if not exists:
                    XSSReport.objects.create(
                        asset=asset,
                        method=method,
                        protocol=protocol,
                        level='medium',
                        url=url_payload,
                        label='new'
                    )

        except Exception as e:
            pass

    with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
        executor.map(test_payload, PAYLOADS)



def try_to_reflection(subdomain , reports: list):
    for report in reports:
        line_clean = re.sub(r'\x1b\[[0-9;]*m', '', report)
        
        parts = line_clean.split('] ')
        parts = [p.replace('[','').replace(']','').strip() for p in parts]
        
        if len(parts) == 4:
            method, protocol, level, url = parts

            exists = XSSReport.objects.filter(asset=subdomain , method=method, level=level,  url=url).exists()
            if not exists:
                XSSReport.objects.create(
                    asset=subdomain,
                    method=method,
                    protocol=protocol,
                    level=level,
                    url=url,
                    label='new'
                )
                try_to_xss (subdomain , method , url , protocol)


def run_reflix(subdomain, path, methods, chunk, headers, thread, delay, timeout_sec=1800):
    try:
        command = [
            "reflix",
            "-l", f'{path}/urls.txt',
            "-X", methods,
            "-c", chunk,
            "-t", thread,
            "-rd", delay,
            "-p", "zerodium",
            "-o", f"{path}/reflix.output",
            "-s"
        ]

        for header in headers:
            command.extend(["-H", header])

        process = subprocess.Popen(
            command,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1,
        )

        reports = []
        start_time = time.monotonic()

        for line in iter(process.stdout.readline, ''):
            reports.append(line.strip())

            if time.monotonic() - start_time > timeout_sec:
                process.kill()
                sendmessage(f"[Vulnerability_Monitor] ⏱ Timeout expired for Reflix {path}/urls.txt", colour="RED")
                break

        try:
            process.wait(timeout=5)
        except subprocess.TimeoutExpired:
            process.kill()

        stderr_output = process.stderr.read()
        if stderr_output.strip():
            sendmessage(f"[Vulnerability_Monitor] ⚠️ Reflix stderr: {stderr_output.strip()}", colour="YELLOW")

        try_to_reflection(subdomain, reports)

    

    except Exception as e:
        sendmessage(f"[Vulnerability_Monitor] ❌ Error Reflix URL {path}/urls.txt : {str(e)}", colour="RED")
        return None



def XSS(self , label):
    subdomains = SubdomainHttpx.objects.filter(label=label)
    sendmessage(f"[vulnerability_monitor] ℹ️ Starting XSS Discovery on Assets (label: {label})")
    clear_labels(self)
    for subdomain in subdomains:    
        sendmessage(f"[vulnerability_monitor] ℹ️ Starting Reflix on {subdomain}")
        headers = list(subdomain.discovered_subdomain.requestheaders_set.all().values_list('header' , flat=True))
        urls = list(subdomain.discovered_subdomain.url_set.filter(label='new').values_list('url', flat=True))
        
        read_write_list(urls , f'{OUTPUT_PATH}/urls.txt', 'w')
        run_reflix(subdomain.discovered_subdomain , f'{OUTPUT_PATH}' , 'GET,POST' , '25' , headers , '1' , '1')
