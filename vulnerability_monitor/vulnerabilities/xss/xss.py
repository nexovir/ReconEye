
import colorama, time, subprocess, requests , re
from asset_monitor.models import *
from urllib.parse import urlparse, parse_qsl, urlencode, urlunparse , parse_qs
from vulnerability_monitor.models import *

OUTPUT_PATH = 'vulnerability_monitor/vulnerabilities/xss/outputs'

def sendmessage(message: str, telegram: bool = False, colour: str = "YELLOW", logger : str = "logger.txt" , silent : bool = False):
    color = getattr(colorama.Fore, colour, colorama.Fore.YELLOW)

    print(color + message + colorama.Style.RESET_ALL)

    time_string = time.strftime("%d/%m/%Y, %H:%M:%S", time.localtime())

    if logger:
        with open(logger, 'a') as file:
            file.write(message + ' -> ' + time_string + '\n')

    if telegram:
        bot_token = {BOT_TOKEN}
        chat_id = "5028701156"
        url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
        payload = {'chat_id': chat_id, 'text': message}

        try:
            response = requests.post(url, data=payload, timeout =10)
            response.raise_for_status()
        except requests.exceptions.RequestException as e:
            sendmessage(f"[ERROR] Telegram message failed: {e}", colour="RED")


def read_write_list(list_data: list, file: str, type: str):

    objects = []
    
    if type == "read" or type == 'r':
        with open(file, 'r') as f:
            objects = list(set(line.strip() for line in f.read().splitlines() if line.strip()))
        return objects

    
    elif type == "write" or type == 'w': 
        with open(file, 'w') as f:
            for item in set(list_data):
                f.write(item.strip() + '\n')


    elif type == "append" or type == 'a':
        try:
            with open(file, 'r') as f:
                existing_items = set(f.read().splitlines())
        except FileNotFoundError:
            existing_items = set()
        
        with open(file, 'a') as f:
            for item in set(list_data):
                if item.strip() and item not in existing_items:
                    f.write(item.strip() + '\n')


def try_to_xss(reports: list):
    cleaned_reports = []
    for report in reports:
        line_clean = re.sub(r'\x1b\[[0-9;]*m', '', report)
        
        parts = line_clean.split('] ')
        parts = [p.replace('[','').replace(']','').strip() for p in parts]
        
        if len(parts) == 4:
            method, protocol, level, url = parts

            exists = XSSReport.objects.filter(method=method, url=url).exists()
            if not exists:
                XSSReport.objects.create(
                    method=method,
                    protocol=protocol,
                    level=level,
                    url=url,
                    label='new'
                )


def run_reflix (path , methods , chunk , headers , thread , delay):
    try : 
        command = [
        "reflix",
        "-l",f'{path}/urls.txt',
        "-X",methods,
        '-c',chunk,
        '-t',thread,
        '-rd', delay,
        '-o' , f'{path}/reflix.output',
        '-s'
        ]

        for header in headers:
            command.extend(["-H", header])

        result = subprocess.run(
            command,
            shell=False,
            check=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        reports = result.stdout.splitlines()
        try_to_xss(reports)

    except Exception as e:
        sendmessage(f"  [ERROR] Error Reflix URL {path}/urls.txt : {str(e)}", colour="RED")
        return None



def XSS(self):
    subdomains = DiscoverSubdomain.objects.all().order_by("-label")
    
    for subdomain in subdomains:    

        headers = list(subdomain.requestheaders_set.all().values_list('header' , flat=True))
        urls = list(subdomain.url_set.filter(label='new').values_list('url', flat=True))
        
        read_write_list(urls , f'{OUTPUT_PATH}/urls.txt', 'w')
        run_reflix(f'{OUTPUT_PATH}' , 'GET,POST' , '25' , headers , '1' , '1')
