
import colorama, time, subprocess, requests , re
from asset_monitor.models import *
from urllib.parse import urlparse, parse_qsl, urlencode, urlunparse , parse_qs
from vulnerability_monitor.models import *
import concurrent.futures , requests , urllib.parse
 

PAYLOADS = ['%22zerodium' , '%27zerodium' , '%3Ezerodium']
OUTPUT_PATH = 'vulnerability_monitor/vulnerabilities/xss/outputs'

def clear_labels(self):
    XSSReport.objects.all().update(label="available")


def sendmessage(message: str, telegram: bool = False, colour: str = "YELLOW", logger : str = "logger.txt" , silent : bool = False):
    color = getattr(colorama.Fore, colour, colorama.Fore.YELLOW)

    print(color + message + colorama.Style.RESET_ALL)

    time_string = time.strftime("%d/%m/%Y, %H:%M:%S", time.localtime())

    if logger:
        with open(logger, 'a') as file:
            file.write(message + ' -> ' + time_string + '\n')

    if telegram:
        bot_token = "6348870305:AAHawStCiN6XfiAu_ZwQJU-x8C1XtKjZ2XA"
        chat_id = "5028701156"
        url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
        payload = {'chat_id': chat_id, 'text': message}

        try:
            response = requests.post(url, data=payload, timeout =10)
            response.raise_for_status()
        except requests.exceptions.RequestException as e:
            sendmessage(f"[ERROR] Telegram message failed: {e}", colour="RED")


def read_write_list(list_data: list, file: str, type: str):
    objects = []
    
    if type == "read" or type == 'r':
        with open(file, 'r') as f:
            objects = list(set(line.strip() for line in f.read().splitlines() if line.strip()))
        return objects

    
    elif type == "write" or type == 'w': 
        with open(file, 'w') as f:
            for item in set(list_data):
                f.write(item.strip() + '\n')


    elif type == "append" or type == 'a':
        try:
            with open(file, 'r') as f:
                existing_items = set(f.read().splitlines())
        except FileNotFoundError:
            existing_items = set()
        
        with open(file, 'a') as f:
            for item in set(list_data):
                if item.strip() and item not in existing_items:
                    f.write(item.strip() + '\n')


def try_to_xss(asset, method, url , protocol):
    def test_payload(payload):
        try:
            url_payload = url.replace("zerodium", payload)
            resp = requests.get(url_payload, timeout=5)
            text = resp.text

            decoded = urllib.parse.unquote(payload)

            if decoded in text:
                exists = XSSReport.objects.filter(asset=asset , method=method,  url=url_payload).exists()
                if not exists:
                    XSSReport.objects.create(
                        asset=asset,
                        method=method,
                        protocol=protocol,
                        level='medium',
                        url=url_payload,
                        label='new'
                    )

        except Exception as e:
            pass

    with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
        executor.map(test_payload, PAYLOADS)



def try_to_reflection(subdomain , reports: list):
    for report in reports:
        line_clean = re.sub(r'\x1b\[[0-9;]*m', '', report)
        
        parts = line_clean.split('] ')
        parts = [p.replace('[','').replace(']','').strip() for p in parts]
        
        if len(parts) == 4:
            method, protocol, level, url = parts

            exists = XSSReport.objects.filter(asset=subdomain , method=method, level=level,  url=url).exists()
            if not exists:
                XSSReport.objects.create(
                    asset=subdomain,
                    method=method,
                    protocol=protocol,
                    level=level,
                    url=url,
                    label='new'
                )
                try_to_xss (subdomain , method , url , protocol)


def run_reflix (subdomain , path , methods , chunk , headers , thread , delay):
    try : 
        command = [
        "reflix",
        "-l",f'{path}/urls.txt',
        "-X",methods,
        '-c',chunk,
        '-t',thread,
        '-rd', delay,
        '-p' , 'zerodium',
        '-o' , f'{path}/reflix.output',
        '-s'
        ]

        for header in headers:
            command.extend(["-H", header])

        result = subprocess.run(
            command,
            shell=False,
            check=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        reports = result.stdout.splitlines()
        try_to_reflection(subdomain , reports)

    except Exception as e:
        sendmessage(f"  [ERROR] Error Reflix URL {path}/urls.txt : {str(e)}", colour="RED")
        return None



def XSS(self):
    subdomains = DiscoverSubdomain.objects.all().order_by("-label")
    clear_labels(self)
    for subdomain in subdomains:    

        headers = list(subdomain.requestheaders_set.all().values_list('header' , flat=True))
        urls = list(subdomain.url_set.filter(label='new').values_list('url', flat=True))
        
        read_write_list(urls , f'{OUTPUT_PATH}/urls.txt', 'w')
        run_reflix(subdomain , f'{OUTPUT_PATH}' , 'GET,POST' , '25' , headers , '1' , '1')
